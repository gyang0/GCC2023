<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title></title>
    </head>

    <canvas id="canvas" width="1000px" height="700px"></canvas>

    <style>
        #canvas {
            border: 2px solid black;
        }
    </style>

    <body>
        <!--
            Some sourcs:
                https://www.climate.gov/news-features/understanding-climate/climate-change-global-sea-level
                https://visibleearth.nasa.gov/images/73934/topography


            [DONE] 1. With some kind of image analyzer, record the values of the pixels as a 2D array.
            [DONE] 2. First, show the starting square of the image successfully on the screen.
            [DONE] 3. Then, warp it to fit the sphere.
            4. After that, make a button with the option to change rotations.
            5. When the user clicks this button, it should flip to the other side.
            6. Make that work too.
            7. Then add multiple readings (angles). Right-and-left arrows for rotations.
            8. Ideally you'd have 8 readings,
            9. Include a mini version of the flat map below, with a highlighted section showing where you are.


            NOTES:
                In the NASA Earth heightmap, it says that the data was scaled 0-6400 meters.
                The Andes mountains are about 3200 meters tall. It's moderately gray.
                So I think it's reasonable to assume that black = 0, white = 6400.

                Looks like the sea level data is at
                    https://climate.nasa.gov/vital-signs/sea-level/

                I need to make an account to download, but it seems to be free.


                Everytime a new angle is requested by the user:
                    Get the appropriate map.
                    Iterate through the values
                    If elevation is high enough, map with brown-green-white colors.
                    Else, show blue-black.
            -->

        <!--
            Todo:
                Extensively comment
                Attempt to make it live-updating...might be feasible, with ~100,000 calculations per second.
                Use let and const instead of var
        -->


        <h1>Hello world</h1>
        <p>Entry for the GCC Hackathon 2023.</p>
        <p>Scratch work: <a href="log.html">Click here</a></p>

        <p>Todo list:</p>
        <ul>
            <li>Sliders for year & sea level</li>
            <li>About page explaining significance (with graphs)</li>
            <li>Sources, GitHub, accuracy warning</li>
        </ul>

        <!-- Sliders: earth rotation, year -->
        <input type="range" min="0" max="6.28" value="0">
        <input type="range" min="1900" max="2100" value="2023">
    </body>

    <script src="page.js"></script>
    <script src="utils.js"></script>

    <!-- Main -->
    <script>
        //var canvas = document.querySelector("#canvas");
        //var gl = canvas.getContext("webgl2");

        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");

        ctx.fillStyle = "black";
        ctx.rect(0, 0, canvas.width, canvas.height);
        ctx.fill();

        ctx.beginPath();
            ctx.moveTo(450, 350);
            ctx.fillStyle = "rgb(80, 80, 80)";
            ctx.ellipse(450, 352, 303, 303, 0, 0, Math.PI*2);
            ctx.fill();
        ctx.closePath();

        
        for(let i = 0; i < MAP_SIZE; i++){
            for(let j = 0; j < MAP_SIZE; j++){

                let ii = i % MAP_WIDTH;
                let jj = j % MAP_HEIGHT;

                ctx.beginPath();
                
                let x = ii * 2*RADIUS/MAP_SIZE - RADIUS;
                
                // Calculations (only approximations, using half-circle equations)
                let newY = jj * 2*RADIUS/MAP_SIZE - RADIUS;
                let curRadDist = Math.sqrt(RADIUS*RADIUS - newY*newY);
                let newX = curRadDist*x/RADIUS;


                // Colors with some shading
                if(mapData[jj][ii] != 0){
                    // 0m - 3200m: dark green to dark brown -> rgb(0, 50, 0) to rgb(100, 50, 0)
                    // 3200m - 6400m: dark brown to white -> rgb(100, 50, 0) to rgb(250, 250, 250)

                    // Little outlines
                    if(mapData[jj][ii] <= 1){
                        ctx.fillStyle = "black";

                    } else if(mapData[jj][ii] <= 125){
                        ctx.fillStyle = toRGBString(
                            100 * mapData[jj][ii]/125,
                            50,
                            0
                        );

                    } else {
                        ctx.fillStyle = toRGBString(
                            100 + 150 * (mapData[jj][ii] - 125)/125,
                            50 + 200 * (mapData[jj][ii] - 125)/125,
                            250 * (mapData[jj][ii] - 125)/125
                        );
                        
                    }

                }
                else
                    ctx.fillStyle = toRGBString(20, 50, 200);

                ctx.rect(newX*3 + 450, newY*3 + 350, 3, 3);
                ctx.fill();
            }
        }
        
    </script>

</html>